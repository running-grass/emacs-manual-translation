msgid ""
msgstr ""
"Project-Id-Version: emacs-manual-chinese\n"
"POT-Creation-Date: 2021-01-06 19:00+0800\n"
"PO-Revision-Date: 2021-01-09 06:15\n"
"Last-Translator: \n"
"Language-Team: Chinese Simplified\n"
"Language: zh_CN\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: emacs-manual-chinese\n"
"X-Crowdin-Project-ID: 436220\n"
"X-Crowdin-Language: zh-CN\n"
"X-Crowdin-File: /27.1/pot/killing.texi.pot\n"
"X-Crowdin-File-ID: 294\n"

#. type: node
#: src/killing.texi:6
#, no-wrap
msgid "Killing"
msgstr ""

#. type: chapter
#: src/killing.texi:7
#, no-wrap
msgid "Killing and Moving Text"
msgstr ""

#. type: Plain text
#: src/killing.texi:15
msgid "In Emacs, @dfn{killing} means erasing text and copying it into the @dfn{kill ring}.  @dfn{Yanking} means bringing text from the kill ring back into the buffer.  (Some applications use the terms ``cutting'' and ``pasting'' for similar operations.)  The kill ring is so-named because it can be visualized as a set of blocks of text arranged in a ring, which you can access in cyclic order.  @xref{Kill Ring}."
msgstr ""

#. type: Plain text
#: src/killing.texi:19
msgid "Killing and yanking are the most common way to move or copy text within Emacs.  It is very versatile, because there are commands for killing many different types of syntactic units."
msgstr ""

#. type: section
#: src/killing.texi:27 src/killing.texi:29 src/killing.texi:30
#, no-wrap
msgid "Deletion and Killing"
msgstr ""

#. type: menuentry
#: src/killing.texi:27
msgid "Commands that remove text."
msgstr ""

#. type: section
#: src/killing.texi:27 src/killing.texi:277 src/killing.texi:278
#, no-wrap
msgid "Yanking"
msgstr ""

#. type: menuentry
#: src/killing.texi:27
msgid "Commands that insert text."
msgstr ""

#. type: node
#: src/killing.texi:27 src/killing.texi:454
#, no-wrap
msgid "Cut and Paste"
msgstr ""

#. type: menuentry
#: src/killing.texi:27
msgid "Clipboard and selections on graphical displays."
msgstr ""

#. type: section
#: src/killing.texi:27 src/killing.texi:645 src/killing.texi:646
#, no-wrap
msgid "Accumulating Text"
msgstr ""

#. type: menuentry
#: src/killing.texi:27
msgid "Other methods to add text to the buffer."
msgstr ""

#. type: section
#: src/killing.texi:27 src/killing.texi:716 src/killing.texi:717
#, no-wrap
msgid "Rectangles"
msgstr ""

#. type: menuentry
#: src/killing.texi:27
msgid "Operating on text in rectangular areas."
msgstr ""

#. type: section
#: src/killing.texi:27 src/killing.texi:889 src/killing.texi:890
#, no-wrap
msgid "CUA Bindings"
msgstr ""

#. type: menuentry
#: src/killing.texi:27
msgid "Using @kbd{C-x}/@kbd{C-c}/@kbd{C-v} to kill and yank."
msgstr ""

#. type: cindex
#: src/killing.texi:32
#, no-wrap
msgid "killing text"
msgstr ""

#. type: cindex
#: src/killing.texi:33
#, no-wrap
msgid "cutting text"
msgstr ""

#. type: cindex
#: src/killing.texi:34
#, no-wrap
msgid "deletion"
msgstr ""

#. type: Plain text
#: src/killing.texi:43
msgid "Most commands which erase text from the buffer save it in the kill ring (@pxref{Kill Ring}).  These are known as @dfn{kill} commands, and their names normally contain the word @samp{kill} (e.g., @code{kill-line}).  The kill ring stores several recent kills, not just the last one, so killing is a very safe operation: you don't have to worry much about losing text that you previously killed.  The kill ring is shared by all buffers, so text that is killed in one buffer can be yanked into another buffer."
msgstr ""

#. type: Plain text
#: src/killing.texi:47
msgid "When you use @kbd{C-/} (@code{undo}) to undo a kill command (@pxref{Undo}), that brings the killed text back into the buffer, but does not remove it from the kill ring."
msgstr ""

#. type: Plain text
#: src/killing.texi:50
msgid "On graphical displays, killing text also copies it to the system clipboard.  @xref{Cut and Paste}."
msgstr ""

#. type: Plain text
#: src/killing.texi:58
msgid "Commands that erase text but do not save it in the kill ring are known as @dfn{delete} commands; their names usually contain the word @samp{delete}.  These include @kbd{C-d} (@code{delete-char}) and @key{DEL} (@code{delete-backward-char}), which delete only one character at a time, and those commands that delete only spaces or newlines.  Commands that can erase significant amounts of nontrivial data generally do a kill operation instead."
msgstr ""

#. type: Plain text
#: src/killing.texi:60
msgid "You can also use the mouse to kill and yank.  @xref{Cut and Paste}."
msgstr ""

#. type: subsection
#: src/killing.texi:68 src/killing.texi:70 src/killing.texi:71
#, no-wrap
msgid "Deletion"
msgstr ""

#. type: menuentry
#: src/killing.texi:68
msgid "Commands for deleting small amounts of text and blank areas."
msgstr ""

#. type: subsection
#: src/killing.texi:68 src/killing.texi:153 src/killing.texi:154
#, no-wrap
msgid "Killing by Lines"
msgstr ""

#. type: menuentry
#: src/killing.texi:68
msgid "How to kill entire lines of text at one time."
msgstr ""

#. type: subsection
#: src/killing.texi:68 src/killing.texi:201 src/killing.texi:202
#, no-wrap
msgid "Other Kill Commands"
msgstr ""

#. type: menuentry
#: src/killing.texi:68
msgid "Commands to kill large regions of text and syntactic units such as words and sentences."
msgstr ""

#. type: node
#: src/killing.texi:68 src/killing.texi:258
#, no-wrap
msgid "Kill Options"
msgstr ""

#. type: menuentry
#: src/killing.texi:68
msgid "Options that affect killing."
msgstr ""

#. type: findex
#: src/killing.texi:72
#, no-wrap
msgid "delete-backward-char"
msgstr ""

#. type: findex
#: src/killing.texi:73
#, no-wrap
msgid "delete-char"
msgstr ""

#. type: Plain text
#: src/killing.texi:78
msgid "Deletion means erasing text and not saving it in the kill ring.  For the most part, the Emacs commands that delete text are those that erase just one character or only whitespace."
msgstr ""

#. type: key{#1}
#: src/killing.texi:80
#, no-wrap
msgid "DEL"
msgstr ""

#. type: key{#1}
#: src/killing.texi:81
#, no-wrap
msgid "BACKSPACE"
msgstr ""

#. type: table
#: src/killing.texi:84
msgid "Delete the previous character, or the text in the region if it is active (@code{delete-backward-char})."
msgstr ""

#. type: key{#1}
#: src/killing.texi:85
#, no-wrap
msgid "Delete"
msgstr ""

#. type: table
#: src/killing.texi:88
msgid "Delete the next character, or the text in the region if it is active (@code{delete-forward-char})."
msgstr ""

#. type: item
#: src/killing.texi:89
#, no-wrap
msgid "C-d"
msgstr ""

#. type: table
#: src/killing.texi:91
msgid "Delete the next character (@code{delete-char})."
msgstr ""

#. type: kindex
#: src/killing.texi:92 src/killing.texi:112
#, no-wrap
msgid "M-\\"
msgstr ""

#. type: table
#: src/killing.texi:94
msgid "Delete spaces and tabs around point (@code{delete-horizontal-space})."
msgstr ""

#. type: item
#: src/killing.texi:94
#, no-wrap
msgid "M-@key{SPC}"
msgstr ""

#. type: table
#: src/killing.texi:97
msgid "Delete spaces and tabs around point, leaving one space (@code{just-one-space})."
msgstr ""

#. type: item
#: src/killing.texi:97
#, no-wrap
msgid "C-x C-o"
msgstr ""

#. type: table
#: src/killing.texi:99
msgid "Delete blank lines around the current line (@code{delete-blank-lines})."
msgstr ""

#. type: item
#: src/killing.texi:99
#, no-wrap
msgid "M-^"
msgstr ""

#. type: table
#: src/killing.texi:102
msgid "Join two lines by deleting the intervening newline, along with any indentation following it (@code{delete-indentation})."
msgstr ""

#. type: Plain text
#: src/killing.texi:111
msgid "We have already described the basic deletion commands @key{DEL} (@code{delete-backward-char}), @key{delete} (@code{delete-forward-char}), and @kbd{C-d} (@code{delete-char}).  @xref{Erasing}.  With a numeric argument, they delete the specified number of characters.  If the numeric argument is omitted or one, @key{DEL} and @key{delete} delete all the text in the region if it is active (@pxref{Using Region})."
msgstr ""

#. type: findex
#: src/killing.texi:113
#, no-wrap
msgid "delete-horizontal-space"
msgstr ""

#. type: kindex
#: src/killing.texi:114
#, no-wrap
msgid "M-SPC"
msgstr ""

#. type: findex
#: src/killing.texi:115
#, no-wrap
msgid "just-one-space"
msgstr ""

#. type: findex
#: src/killing.texi:116
#, no-wrap
msgid "cycle-spacing"
msgstr ""

#. type: Plain text
#: src/killing.texi:132
msgid "The other delete commands are those that delete only whitespace characters: spaces, tabs and newlines.  @kbd{M-\\} (@code{delete-horizontal-space}) deletes all the spaces and tab characters before and after point.  With a prefix argument, this only deletes spaces and tab characters before point.  @kbd{M-@key{SPC}} (@code{just-one-space}) does likewise but leaves a single space before point, regardless of the number of spaces that existed previously (even if there were none before).  With a numeric argument @var{n}, it leaves @var{n} spaces before point if @var{n} is positive; if @var{n} is negative, it deletes newlines in addition to spaces and tabs, leaving @minus{}@var{n} spaces before point.  The command @code{cycle-spacing} acts like a more flexible version of @code{just-one-space}.  It does different things if you call it repeatedly in succession.  The first call acts like @code{just-one-space}, the next removes all whitespace, and a third call restores the original whitespace."
msgstr ""

#. type: Plain text
#: src/killing.texi:137
msgid "@kbd{C-x C-o} (@code{delete-blank-lines}) deletes all blank lines after the current line.  If the current line is blank, it deletes all blank lines preceding the current line as well (leaving one blank line, the current line).  On a solitary blank line, it deletes that line."
msgstr ""

#. type: Plain text
#: src/killing.texi:141
msgid "@kbd{M-^} (@code{delete-indentation}) joins the current line and the previous line, by deleting a newline and all surrounding spaces, usually leaving a single space.  @xref{Indentation,M-^}."
msgstr ""

#. type: findex
#: src/killing.texi:143
#, no-wrap
msgid "delete-duplicate-lines"
msgstr ""

#. type: Plain text
#: src/killing.texi:152
msgid "The command @code{delete-duplicate-lines} searches the region for identical lines, and removes all but one copy of each.  Normally it keeps the first instance of each repeated line, but with a @kbd{C-u} prefix argument it keeps the last.  With a @kbd{C-u C-u} prefix argument, it only searches for adjacent identical lines.  This is a more efficient mode of operation, useful when the lines have already been sorted.  With a @kbd{C-u C-u C-u} prefix argument, it retains repeated blank lines."
msgstr ""

#. type: kindex
#: src/killing.texi:157 src/killing.texi:163
#, no-wrap
msgid "C-k"
msgstr ""

#. type: table
#: src/killing.texi:159
msgid "Kill rest of line or one or more lines (@code{kill-line})."
msgstr ""

#. type: kindex
#: src/killing.texi:159 src/killing.texi:194
#, no-wrap
msgid "C-S-backspace"
msgstr ""

#. type: table
#: src/killing.texi:161
msgid "Kill an entire line at once (@code{kill-whole-line})"
msgstr ""

#. type: findex
#: src/killing.texi:164
#, no-wrap
msgid "kill-line"
msgstr ""

#. type: Plain text
#: src/killing.texi:171
msgid "The simplest kill command is @kbd{C-k} (@code{kill-line}).  If used at the end of a line, it kills the line-ending newline character, merging the next line into the current one (thus, a blank line is entirely removed).  Otherwise, @kbd{C-k} kills all the text from point up to the end of the line; if point was originally at the beginning of the line, this leaves the line blank."
msgstr ""

#. type: Plain text
#: src/killing.texi:177
msgid "Spaces and tabs at the end of the line are ignored when deciding which case applies.  As long as point is after the last non-whitespace character in the line, you can be sure that @kbd{C-k} will kill the newline.  To kill an entire non-blank line, go to the beginning and type @kbd{C-k} twice."
msgstr ""

#. type: Plain text
#: src/killing.texi:180
msgid "In this context, ``line'' means a logical text line, not a screen line (@pxref{Continuation Lines})."
msgstr ""

#. type: Plain text
#: src/killing.texi:188
msgid "When @kbd{C-k} is given a positive argument @var{n}, it kills @var{n} lines and the newlines that follow them (text on the current line before point is not killed).  With a negative argument @minus{}@var{n}, it kills @var{n} lines preceding the current line, together with the text on the current line before point.  @kbd{C-k} with an argument of zero kills the text before point on the current line."
msgstr ""

#. type: findex
#: src/killing.texi:189 src/killing.texi:195
#, no-wrap
msgid "kill-whole-line"
msgstr ""

#. type: Plain text
#: src/killing.texi:193
msgid "If the variable @code{kill-whole-line} is non-@code{nil}, @kbd{C-k} at the very beginning of a line kills the entire line including the following newline.  This variable is normally @code{nil}."
msgstr ""

#. type: Plain text
#: src/killing.texi:200
msgid "@kbd{C-S-backspace} (@code{kill-whole-line}) kills a whole line including its newline, regardless of the position of point within the line.  Note that many text terminals will prevent you from typing the key sequence @kbd{C-S-backspace}."
msgstr ""

#. type: kindex
#: src/killing.texi:205 src/killing.texi:226
#, no-wrap
msgid "C-w"
msgstr ""

#. type: table
#: src/killing.texi:207
msgid "Kill the region (@code{kill-region})."
msgstr ""

#. type: kindex
#: src/killing.texi:207 src/killing.texi:228
#, no-wrap
msgid "M-w"
msgstr ""

#. type: table
#: src/killing.texi:209
msgid "Copy the region into the kill ring (@code{kill-ring-save})."
msgstr ""

#. type: item
#: src/killing.texi:209
#, no-wrap
msgid "M-d"
msgstr ""

#. type: table
#: src/killing.texi:211
msgid "Kill the next word (@code{kill-word}).  @xref{Words}."
msgstr ""

#. type: item
#: src/killing.texi:211
#, no-wrap
msgid "M-@key{DEL}"
msgstr ""

#. type: table
#: src/killing.texi:213
msgid "Kill one word backwards (@code{backward-kill-word})."
msgstr ""

#. type: item
#: src/killing.texi:213
#, no-wrap
msgid "C-x @key{DEL}"
msgstr ""

#. type: table
#: src/killing.texi:216
msgid "Kill back to beginning of sentence (@code{backward-kill-sentence}).  @xref{Sentences}."
msgstr ""

#. type: item
#: src/killing.texi:216
#, no-wrap
msgid "M-k"
msgstr ""

#. type: table
#: src/killing.texi:218
msgid "Kill to the end of the sentence (@code{kill-sentence})."
msgstr ""

#. type: item
#: src/killing.texi:218
#, no-wrap
msgid "C-M-k"
msgstr ""

#. type: table
#: src/killing.texi:220
msgid "Kill the following balanced expression (@code{kill-sexp}).  @xref{Expressions}."
msgstr ""

#. type: item
#: src/killing.texi:220
#, no-wrap
msgid "M-z @var{char}"
msgstr ""

#. type: table
#: src/killing.texi:222
msgid "Kill through the next occurrence of @var{char} (@code{zap-to-char})."
msgstr ""

#. type: item
#: src/killing.texi:222
#, no-wrap
msgid "M-x zap-up-to-char @var{char}"
msgstr ""

#. type: table
#: src/killing.texi:224
msgid "Kill up to, but not including, the next occurrence of @var{char}."
msgstr ""

#. type: findex
#: src/killing.texi:227
#, no-wrap
msgid "kill-region"
msgstr ""

#. type: findex
#: src/killing.texi:229
#, no-wrap
msgid "kill-ring-save"
msgstr ""

#. type: Plain text
#: src/killing.texi:237
msgid "One of the commonly-used kill commands is @kbd{C-w} (@code{kill-region}), which kills the text in the region (@pxref{Mark}).  Similarly, @kbd{M-w} (@code{kill-ring-save}) copies the text in the region into the kill ring without removing it from the buffer.  If the mark is inactive when you type @kbd{C-w} or @kbd{M-w}, the command acts on the text between point and where you last set the mark (@pxref{Using Region})."
msgstr ""

#. type: Plain text
#: src/killing.texi:242
msgid "Emacs also provides commands to kill specific syntactic units: words, with @kbd{M-@key{DEL}} and @kbd{M-d} (@pxref{Words}); balanced expressions, with @kbd{C-M-k} (@pxref{Expressions}); and sentences, with @kbd{C-x @key{DEL}} and @kbd{M-k} (@pxref{Sentences})."
msgstr ""

#. type: kindex
#: src/killing.texi:243
#, no-wrap
msgid "M-z"
msgstr ""

#. type: findex
#: src/killing.texi:244
#, no-wrap
msgid "zap-to-char"
msgstr ""

#. type: Plain text
#: src/killing.texi:253
msgid "The command @kbd{M-z} (@code{zap-to-char}) combines killing with searching: it reads a character and kills from point up to (and including) the next occurrence of that character in the buffer.  A numeric argument acts as a repeat count; a negative argument means to search backward and kill text before point.  A history of previously used characters is maintained and can be accessed via the @kbd{M-p}/@kbd{M-n} keystrokes.  This is mainly useful if the character to be used has to be entered via a complicated input method."
msgstr ""

#. type: findex
#: src/killing.texi:253
#, no-wrap
msgid "zap-up-to-char"
msgstr ""

#. type: Plain text
#: src/killing.texi:257
msgid "A similar command @code{zap-up-to-char} kills from point up to, but not including the next occurrence of a character, with numeric argument acting as a repeat count."
msgstr ""

#. type: subsection
#: src/killing.texi:259
#, no-wrap
msgid "Options for Killing"
msgstr ""

#. type: vindex
#: src/killing.texi:261
#, no-wrap
msgid "kill-read-only-ok"
msgstr ""

#. type: cindex
#: src/killing.texi:262
#, no-wrap
msgid "read-only text, killing"
msgstr ""

#. type: Plain text
#: src/killing.texi:271
msgid "Some specialized buffers contain @dfn{read-only text}, which cannot be modified and therefore cannot be killed.  The kill commands work specially in a read-only buffer: they move over text and copy it to the kill ring, without actually deleting it from the buffer.  Normally, they also beep and display an error message when this happens.  But if you set the variable @code{kill-read-only-ok} to a non-@code{nil} value, they just print a message in the echo area to explain why the text has not been erased."
msgstr ""

#. type: vindex
#: src/killing.texi:272
#, no-wrap
msgid "kill-do-not-save-duplicates"
msgstr ""

#. type: Plain text
#: src/killing.texi:276
msgid "If you change the variable @code{kill-do-not-save-duplicates} to a non-@code{nil} value, identical subsequent kills yield a single kill-ring entry, without duplication."
msgstr ""

#. type: cindex
#: src/killing.texi:279
#, no-wrap
msgid "moving text"
msgstr ""

#. type: cindex
#: src/killing.texi:280
#, no-wrap
msgid "copying text"
msgstr ""

#. type: cindex
#: src/killing.texi:281
#, no-wrap
msgid "kill ring"
msgstr ""

#. type: cindex
#: src/killing.texi:282
#, no-wrap
msgid "yanking"
msgstr ""

#. type: cindex
#: src/killing.texi:283
#, no-wrap
msgid "pasting"
msgstr ""

#. type: Plain text
#: src/killing.texi:287
msgid "@dfn{Yanking} means reinserting text previously killed.  The usual way to move or copy text is to kill it and then yank it elsewhere."
msgstr ""

#. type: kindex
#: src/killing.texi:289 src/killing.texi:299
#, no-wrap
msgid "C-y"
msgstr ""

#. type: table
#: src/killing.texi:291
msgid "Yank the last kill into the buffer, at point (@code{yank})."
msgstr ""

#. type: kindex
#: src/killing.texi:291 src/killing.texi:359
#, no-wrap
msgid "M-y"
msgstr ""

#. type: table
#: src/killing.texi:294
msgid "Replace the text just yanked with an earlier batch of killed text (@code{yank-pop}).  @xref{Earlier Kills}."
msgstr ""

#. type: kindex
#: src/killing.texi:294 src/killing.texi:438
#, no-wrap
msgid "C-M-w"
msgstr ""

#. type: table
#: src/killing.texi:297
msgid "Cause the following command, if it is a kill command, to append to the previous kill (@code{append-next-kill}).  @xref{Appending Kills}."
msgstr ""

#. type: findex
#: src/killing.texi:300
#, no-wrap
msgid "yank"
msgstr ""

#. type: Plain text
#: src/killing.texi:306
msgid "The basic yanking command is @kbd{C-y} (@code{yank}).  It inserts the most recent kill, leaving the cursor at the end of the inserted text.  It also sets the mark at the beginning of the inserted text, without activating the mark; this lets you jump easily to that position, if you wish, with @kbd{C-u C-@key{SPC}} (@pxref{Mark Ring})."
msgstr ""

#. type: Plain text
#: src/killing.texi:312
msgid "With a plain prefix argument (@kbd{C-u C-y}), the command instead leaves the cursor in front of the inserted text, and sets the mark at the end.  Using any other prefix argument specifies an earlier kill; e.g., @kbd{C-u 4 C-y} reinserts the fourth most recent kill.  @xref{Earlier Kills}."
msgstr ""

#. type: Plain text
#: src/killing.texi:320
msgid "On graphical displays, @kbd{C-y} first checks if another application has placed any text in the system clipboard more recently than the last Emacs kill.  If so, it inserts the clipboard's text instead.  Thus, Emacs effectively treats ``cut'' or ``copy'' clipboard operations performed in other applications like Emacs kills, except that they are not recorded in the kill ring.  @xref{Cut and Paste}, for details."
msgstr ""

#. type: node
#: src/killing.texi:325 src/killing.texi:327
#, no-wrap
msgid "Kill Ring"
msgstr ""

#. type: menuentry
#: src/killing.texi:325
msgid "Where killed text is stored."
msgstr ""

#. type: node
#: src/killing.texi:325 src/killing.texi:349
#, no-wrap
msgid "Earlier Kills"
msgstr ""

#. type: menuentry
#: src/killing.texi:325
msgid "Yanking something killed some time ago."
msgstr ""

#. type: subsection
#: src/killing.texi:325 src/killing.texi:397 src/killing.texi:398
#, no-wrap
msgid "Appending Kills"
msgstr ""

#. type: menuentry
#: src/killing.texi:325
msgid "Several kills in a row all yank together."
msgstr ""

#. type: subsection
#: src/killing.texi:328
#, no-wrap
msgid "The Kill Ring"
msgstr ""

#. type: Plain text
#: src/killing.texi:337
msgid "The @dfn{kill ring} is a list of blocks of text that were previously killed.  There is only one kill ring, shared by all buffers, so you can kill text in one buffer and yank it in another buffer.  This is the usual way to move text from one buffer to another.  (There are several other methods: for instance, you could store the text in a register; see @ref{Registers}.  @xref{Accumulating Text}, for some other ways to move text around.)"
msgstr ""

#. type: vindex
#: src/killing.texi:338
#, no-wrap
msgid "kill-ring-max"
msgstr ""

#. type: Plain text
#: src/killing.texi:343
msgid "The maximum number of entries in the kill ring is controlled by the variable @code{kill-ring-max}.  The default is 60.  If you make a new kill when this limit has been reached, Emacs makes room by deleting the oldest entry in the kill ring."
msgstr ""

#. type: vindex
#: src/killing.texi:344
#, no-wrap
msgid "kill-ring"
msgstr ""

#. type: Plain text
#: src/killing.texi:348
msgid "The actual contents of the kill ring are stored in a variable named @code{kill-ring}; you can view the entire contents of the kill ring with @kbd{C-h v kill-ring}."
msgstr ""

#. type: subsection
#: src/killing.texi:350
#, no-wrap
msgid "Yanking Earlier Kills"
msgstr ""

#. type: cindex
#: src/killing.texi:351
#, no-wrap
msgid "yanking previous kills"
msgstr ""

#. type: Plain text
#: src/killing.texi:358
msgid "As explained in @ref{Yanking}, you can use a numeric argument to @kbd{C-y} to yank text that is no longer the most recent kill.  This is useful if you remember which kill ring entry you want.  If you don't, you can use the @kbd{M-y} (@code{yank-pop}) command to cycle through the possibilities."
msgstr ""

#. type: findex
#: src/killing.texi:360
#, no-wrap
msgid "yank-pop"
msgstr ""

#. type: Plain text
#: src/killing.texi:367
msgid "If the previous command was a yank command, @kbd{M-y} takes the text that was yanked and replaces it with the text from an earlier kill.  So, to recover the text of the next-to-the-last kill, first use @kbd{C-y} to yank the last kill, and then use @kbd{M-y} to replace it with the previous kill.  @kbd{M-y} is allowed only after a @kbd{C-y} or another @kbd{M-y}."
msgstr ""

#. type: Plain text
#: src/killing.texi:377
msgid "You can understand @kbd{M-y} in terms of a last-yank pointer which points at an entry in the kill ring.  Each time you kill, the last-yank pointer moves to the newly made entry at the front of the ring.  @kbd{C-y} yanks the entry which the last-yank pointer points to.  @kbd{M-y} moves the last-yank pointer to a different entry, and the text in the buffer changes to match.  Enough @kbd{M-y} commands can move the pointer to any entry in the ring, so you can get any entry into the buffer.  Eventually the pointer reaches the end of the ring; the next @kbd{M-y} loops back around to the first entry again."
msgstr ""

#. type: Plain text
#: src/killing.texi:381
msgid "@kbd{M-y} moves the last-yank pointer around the ring, but it does not change the order of the entries in the ring, which always runs from the most recent kill at the front to the oldest one still remembered."
msgstr ""

#. type: Plain text
#: src/killing.texi:386
msgid "@kbd{M-y} can take a numeric argument, which tells it how many entries to advance the last-yank pointer by.  A negative argument moves the pointer toward the front of the ring; from the front of the ring, it moves around to the last entry and continues forward from there."
msgstr ""

#. type: Plain text
#: src/killing.texi:393
msgid "Once the text you are looking for is brought into the buffer, you can stop doing @kbd{M-y} commands and it will stay there.  It's just a copy of the kill ring entry, so editing it in the buffer does not change what's in the ring.  As long as no new killing is done, the last-yank pointer remains at the same place in the kill ring, so repeating @kbd{C-y} will yank another copy of the same previous kill."
msgstr ""

#. type: Plain text
#: src/killing.texi:396
msgid "When you call @kbd{C-y} with a numeric argument, that also sets the last-yank pointer to the entry that it yanks."
msgstr ""

#. type: cindex
#: src/killing.texi:400
#, no-wrap
msgid "appending kills in the ring"
msgstr ""

#. type: Plain text
#: src/killing.texi:405
msgid "Normally, each kill command pushes a new entry onto the kill ring.  However, two or more kill commands in a row combine their text into a single entry, so that a single @kbd{C-y} yanks all the text as a unit, just as it was before it was killed."
msgstr ""

#. type: Plain text
#: src/killing.texi:410
msgid "Thus, if you want to yank text as a unit, you need not kill all of it with one command; you can keep killing line after line, or word after word, until you have killed it all, and you can still get it all back at once."
msgstr ""

#. type: Plain text
#: src/killing.texi:417
msgid "Commands that kill forward from point add onto the end of the previous killed text.  Commands that kill backward from point add text onto the beginning.  This way, any sequence of mixed forward and backward kill commands puts all the killed text into one entry without rearrangement.  Numeric arguments do not break the sequence of appending kills.  For example, suppose the buffer contains this text:"
msgstr ""

#. type: example
#: src/killing.texi:420
#, no-wrap
msgid "This is a line @point{}of sample text.\n"
msgstr ""

#. type: Plain text
#: src/killing.texi:429
msgid "with point shown by @point{}.  If you type @kbd{M-d M-@key{DEL} M-d M-@key{DEL}}, killing alternately forward and backward, you end up with @samp{a line of sample} as one entry in the kill ring, and @w{@samp{This is@ @ text.}} in the buffer.  (Note the double space between @samp{is} and @samp{text}, which you can clean up with @kbd{M-@key{SPC}} or @kbd{M-q}.)"
msgstr ""

#. type: Plain text
#: src/killing.texi:437
msgid "Another way to kill the same text is to move back two words with @kbd{M-b M-b}, then kill all four words forward with @kbd{C-u M-d}.  This produces exactly the same results in the buffer and in the kill ring.  @kbd{M-f M-f C-u M-@key{DEL}} kills the same text, all going backward; once again, the result is the same.  The text in the kill ring entry always has the same order that it had in the buffer before you killed it."
msgstr ""

#. type: findex
#: src/killing.texi:439
#, no-wrap
msgid "append-next-kill"
msgstr ""

#. type: Plain text
#: src/killing.texi:450
msgid "If a kill command is separated from the last kill command by other commands (not just numeric arguments), it starts a new entry on the kill ring.  But you can force it to combine with the last killed text, by typing @kbd{C-M-w} (@code{append-next-kill}) right beforehand.  The @kbd{C-M-w} tells its following command, if it is a kill command, to treat the kill as part of the sequence of previous kills.  As usual, the kill is appended to the previous killed text if the command kills forward, and prepended if the command kills backward.  In this way, you can kill several separated pieces of text and accumulate them to be yanked back in one place."
msgstr ""

#. type: Plain text
#: src/killing.texi:453
msgid "A kill command following @kbd{M-w} (@code{kill-ring-save}) does not append to the text that @kbd{M-w} copied into the kill ring."
msgstr ""

#. type: section
#: src/killing.texi:455
#, no-wrap
msgid "``Cut and Paste'' Operations on Graphical Displays"
msgstr ""

#. type: cindex
#: src/killing.texi:456
#, no-wrap
msgid "cut"
msgstr ""

#. type: cindex
#: src/killing.texi:457
#, no-wrap
msgid "copy"
msgstr ""

#. type: cindex
#: src/killing.texi:458
#, no-wrap
msgid "paste"
msgstr ""

#. type: Plain text
#: src/killing.texi:467
msgid "In most graphical desktop environments, you can transfer data (usually text) between different applications using a system facility called the @dfn{clipboard}.  On X, two other similar facilities are available: the primary selection and the secondary selection.  When Emacs is run on a graphical display, its kill and yank commands integrate with these facilities, so that you can easily transfer text between Emacs and other graphical applications."
msgstr ""

#. type: Plain text
#: src/killing.texi:474
msgid "By default, Emacs uses UTF-8 as the coding system for inter-program text transfers.  If you find that the pasted text is not what you expected, you can specify another coding system by typing @kbd{C-x @key{RET} x} or @kbd{C-x @key{RET} X}.  You can also request a different data type by customizing @code{x-select-request-type}.  @xref{Communication Coding}."
msgstr ""

#. type: node
#: src/killing.texi:479 src/killing.texi:481
#, no-wrap
msgid "Clipboard"
msgstr ""

#. type: menuentry
#: src/killing.texi:479
msgid "How Emacs uses the system clipboard."
msgstr ""

#. type: node
#: src/killing.texi:479 src/killing.texi:548
#, no-wrap
msgid "Primary Selection"
msgstr ""

#. type: menuentry
#: src/killing.texi:479
msgid "The temporarily selected text selection."
msgstr ""

#. type: subsection
#: src/killing.texi:479 src/killing.texi:590 src/killing.texi:591
#, no-wrap
msgid "Secondary Selection"
msgstr ""

#. type: menuentry
#: src/killing.texi:479
msgid "Cutting without altering point and mark."
msgstr ""

#. type: subsection
#: src/killing.texi:482
#, no-wrap
msgid "Using the Clipboard"
msgstr ""

#. type: cindex
#: src/killing.texi:483
#, no-wrap
msgid "clipboard"
msgstr ""

#. type: Plain text
#: src/killing.texi:488
msgid "The @dfn{clipboard} is the facility that most graphical applications use for ``cutting and pasting''.  When the clipboard exists, the kill and yank commands in Emacs make use of it."
msgstr ""

#. type: Plain text
#: src/killing.texi:493
msgid "When you kill some text with a command such as @kbd{C-w} (@code{kill-region}), or copy it to the kill ring with a command such as @kbd{M-w} (@code{kill-ring-save}), that text is also put in the clipboard."
msgstr ""

#. type: vindex
#: src/killing.texi:494
#, no-wrap
msgid "save-interprogram-paste-before-kill"
msgstr ""

#. type: Plain text
#: src/killing.texi:501
msgid "When an Emacs kill command puts text in the clipboard, the existing clipboard contents are normally lost.  Optionally, you can change @code{save-interprogram-paste-before-kill} to @code{t}.  Then Emacs will first save the clipboard to its kill ring, preventing you from losing the old clipboard data---at the risk of high memory consumption if that data turns out to be large."
msgstr ""

#. type: Plain text
#: src/killing.texi:507
msgid "Yank commands, such as @kbd{C-y} (@code{yank}), also use the clipboard.  If another application ``owns'' the clipboard---i.e., if you cut or copied text there more recently than your last kill command in Emacs---then Emacs yanks from the clipboard instead of the kill ring."
msgstr ""

#. type: vindex
#: src/killing.texi:508
#, no-wrap
msgid "yank-pop-change-selection"
msgstr ""

#. type: Plain text
#: src/killing.texi:513
msgid "Normally, rotating the kill ring with @kbd{M-y} (@code{yank-pop})  does not alter the clipboard.  However, if you change @code{yank-pop-change-selection} to @code{t}, then @kbd{M-y} saves the new yank to the clipboard."
msgstr ""

#. type: vindex
#: src/killing.texi:514
#, no-wrap
msgid "select-enable-clipboard"
msgstr ""

#. type: Plain text
#: src/killing.texi:517
msgid "To prevent kill and yank commands from accessing the clipboard, change the variable @code{select-enable-clipboard} to @code{nil}."
msgstr ""

#. type: cindex
#: src/killing.texi:518
#, no-wrap
msgid "clipboard manager"
msgstr ""

#. type: vindex
#: src/killing.texi:519
#, no-wrap
msgid "x-select-enable-clipboard-manager"
msgstr ""

#. type: Plain text
#: src/killing.texi:528
msgid "Many X desktop environments support a feature called the @dfn{clipboard manager}.  If you exit Emacs while it is the current ``owner'' of the clipboard data, and there is a clipboard manager running, Emacs transfers the clipboard data to the clipboard manager so that it is not lost.  In some circumstances, this may cause a delay when exiting Emacs; if you wish to prevent Emacs from transferring data to the clipboard manager, change the variable @code{x-select-enable-clipboard-manager} to @code{nil}."
msgstr ""

#. type: Plain text
#: src/killing.texi:532
msgid "Since strings containing NUL bytes are usually truncated when passed through the clipboard, Emacs replaces such characters with ``\\0'' before transferring them to the system's clipboard."
msgstr ""

#. type: vindex
#: src/killing.texi:533
#, no-wrap
msgid "select-enable-primary"
msgstr ""

#. type: findex
#: src/killing.texi:534
#, no-wrap
msgid "clipboard-kill-region"
msgstr ""

#. type: findex
#: src/killing.texi:535
#, no-wrap
msgid "clipboard-kill-ring-save"
msgstr ""

#. type: findex
#: src/killing.texi:536
#, no-wrap
msgid "clipboard-yank"
msgstr ""

#. type: Plain text
#: src/killing.texi:547
msgid "Prior to Emacs 24, the kill and yank commands used the primary selection (@pxref{Primary Selection}), not the clipboard.  If you prefer this behavior, change @code{select-enable-clipboard} to @code{nil}, @code{select-enable-primary} to @code{t}, and @code{mouse-drag-copy-region} to @code{t}.  In this case, you can use the following commands to act explicitly on the clipboard: @code{clipboard-kill-region} kills the region and saves it to the clipboard; @code{clipboard-kill-ring-save} copies the region to the kill ring and saves it to the clipboard; and @code{clipboard-yank} yanks the contents of the clipboard at point."
msgstr ""

#. type: subsection
#: src/killing.texi:549
#, no-wrap
msgid "Cut and Paste with Other Window Applications"
msgstr ""

#. type: cindex
#: src/killing.texi:550
#, no-wrap
msgid "X cutting and pasting"
msgstr ""

#. type: cindex
#: src/killing.texi:551
#, no-wrap
msgid "X selection"
msgstr ""

#. type: cindex
#: src/killing.texi:552
#, no-wrap
msgid "primary selection"
msgstr ""

#. type: cindex
#: src/killing.texi:553
#, no-wrap
msgid "selection, primary"
msgstr ""

#. type: Plain text
#: src/killing.texi:563
msgid "Under the X Window System, there exists a @dfn{primary selection} containing the last stretch of text selected in an X application (usually by dragging the mouse).  Typically, this text can be inserted into other X applications by @kbd{mouse-2} clicks.  The primary selection is separate from the clipboard.  Its contents are more fragile; they are overwritten each time you select text with the mouse, whereas the clipboard is only overwritten by explicit cut or copy commands."
msgstr ""

#. type: Plain text
#: src/killing.texi:569
msgid "Under X, whenever the region is active (@pxref{Mark}), the text in the region is saved in the primary selection.  This applies regardless of whether the region was made by dragging or clicking the mouse (@pxref{Mouse Commands}), or by keyboard commands (e.g., by typing @kbd{C-@key{SPC}} and moving point; @pxref{Setting Mark})."
msgstr ""

#. type: vindex
#: src/killing.texi:570
#, no-wrap
msgid "select-active-regions"
msgstr ""

#. type: Plain text
#: src/killing.texi:577
msgid "If you change the variable @code{select-active-regions} to @code{only}, Emacs saves only temporarily active regions to the primary selection, i.e., those made with the mouse or with shift selection (@pxref{Shift Selection}).  If you change @code{select-active-regions} to @code{nil}, Emacs avoids saving active regions to the primary selection entirely."
msgstr ""

#. type: Plain text
#: src/killing.texi:581
msgid "To insert the primary selection into an Emacs buffer, click @kbd{mouse-2} (@code{mouse-yank-primary}) where you want to insert it.  @xref{Mouse Commands}."
msgstr ""

#. type: cindex
#: src/killing.texi:582
#, no-wrap
msgid "MS-Windows, and primary selection"
msgstr ""

#. type: Plain text
#: src/killing.texi:589
msgid "MS-Windows provides no primary selection, but Emacs emulates it within a single Emacs session by storing the selected text internally.  Therefore, all the features and commands related to the primary selection work on Windows as they do on X, for cutting and pasting within the same session, but not across Emacs sessions or with other applications."
msgstr ""

#. type: cindex
#: src/killing.texi:592
#, no-wrap
msgid "secondary selection"
msgstr ""

#. type: Plain text
#: src/killing.texi:598
msgid "In addition to the primary selection, the X Window System provides a second similar facility known as the @dfn{secondary selection}.  Nowadays, few X applications make use of the secondary selection, but you can access it using the following Emacs commands:"
msgstr ""

#. type: findex
#: src/killing.texi:600
#, no-wrap
msgid "mouse-set-secondary"
msgstr ""

#. type: item
#: src/killing.texi:601 src/killing.texi:603
#, no-wrap
msgid "M-Drag-mouse-1"
msgstr ""

#. type: cindex
#: src/killing.texi:602
#, no-wrap
msgid "@code{secondary-selection} face"
msgstr ""

#. type: table
#: src/killing.texi:610
msgid "Set the secondary selection, with one end at the place where you press down the button, and the other end at the place where you release it (@code{mouse-set-secondary}).  The selected text is highlighted, using the @code{secondary-selection} face, as you drag.  The window scrolls automatically if you drag the mouse off the top or bottom of the window, just like @code{mouse-set-region} (@pxref{Mouse Commands})."
msgstr ""

#. type: table
#: src/killing.texi:612
msgid "This command does not alter the kill ring."
msgstr ""

#. type: findex
#: src/killing.texi:613
#, no-wrap
msgid "mouse-start-secondary"
msgstr ""

#. type: item
#: src/killing.texi:614 src/killing.texi:615
#, no-wrap
msgid "M-mouse-1"
msgstr ""

#. type: table
#: src/killing.texi:620
msgid "Set one endpoint for the @dfn{secondary selection} (@code{mouse-start-secondary}); use @kbd{M-mouse-3} to set the other end and complete the selection.  This command cancels any existing secondary selection, when it starts a new one."
msgstr ""

#. type: findex
#: src/killing.texi:621
#, no-wrap
msgid "mouse-secondary-save-then-kill"
msgstr ""

#. type: item
#: src/killing.texi:622 src/killing.texi:623
#, no-wrap
msgid "M-mouse-3"
msgstr ""

#. type: table
#: src/killing.texi:630
msgid "Set the secondary selection (@code{mouse-secondary-save-then-kill}), with one end at the position you click @kbd{M-mouse-3}, and the other at the position specified previously with @kbd{M-mouse-1}.  This also puts the selected text in the kill ring.  A second @kbd{M-mouse-3} at the same place kills the text selected by the secondary selection just made."
msgstr ""

#. type: findex
#: src/killing.texi:631
#, no-wrap
msgid "mouse-yank-secondary"
msgstr ""

#. type: item
#: src/killing.texi:632 src/killing.texi:633
#, no-wrap
msgid "M-mouse-2"
msgstr ""

#. type: table
#: src/killing.texi:636
msgid "Insert the secondary selection where you click, placing point at the end of the yanked text (@code{mouse-yank-secondary})."
msgstr ""

#. type: Plain text
#: src/killing.texi:640
msgid "Double or triple clicking of @kbd{M-mouse-1} operates on words and lines, much like @kbd{mouse-1}."
msgstr ""

#. type: Plain text
#: src/killing.texi:644
msgid "If @code{mouse-yank-at-point} is non-@code{nil}, @kbd{M-mouse-2} yanks at point.  Then it does not matter precisely where you click, or even which of the frame's windows you click on.  @xref{Mouse Commands}."
msgstr ""

#. type: findex
#: src/killing.texi:647
#, no-wrap
msgid "append-to-buffer"
msgstr ""

#. type: findex
#: src/killing.texi:648
#, no-wrap
msgid "prepend-to-buffer"
msgstr ""

#. type: findex
#: src/killing.texi:649
#, no-wrap
msgid "copy-to-buffer"
msgstr ""

#. type: findex
#: src/killing.texi:650
#, no-wrap
msgid "append-to-file"
msgstr ""

#. type: cindex
#: src/killing.texi:652
#, no-wrap
msgid "accumulating scattered text"
msgstr ""

#. type: Plain text
#: src/killing.texi:658
msgid "Usually we copy or move text by killing it and yanking it, but there are other convenient methods for copying one block of text in many places, or for copying many scattered blocks of text into one place.  Here we describe the commands to accumulate scattered pieces of text into a buffer or into a file."
msgstr ""

#. type: item
#: src/killing.texi:660
#, no-wrap
msgid "M-x append-to-buffer"
msgstr ""

#. type: table
#: src/killing.texi:662
msgid "Append region to the contents of a specified buffer."
msgstr ""

#. type: item
#: src/killing.texi:662
#, no-wrap
msgid "M-x prepend-to-buffer"
msgstr ""

#. type: table
#: src/killing.texi:664
msgid "Prepend region to the contents of a specified buffer."
msgstr ""

#. type: item
#: src/killing.texi:664
#, no-wrap
msgid "M-x copy-to-buffer"
msgstr ""

#. type: table
#: src/killing.texi:666
msgid "Copy region into a specified buffer, deleting that buffer's old contents."
msgstr ""

#. type: item
#: src/killing.texi:666
#, no-wrap
msgid "M-x insert-buffer"
msgstr ""

#. type: table
#: src/killing.texi:668
msgid "Insert the contents of a specified buffer into current buffer at point."
msgstr ""

#. type: item
#: src/killing.texi:668
#, no-wrap
msgid "M-x append-to-file"
msgstr ""

#. type: table
#: src/killing.texi:670
msgid "Append region to the contents of a specified file, at the end."
msgstr ""

#. type: Plain text
#: src/killing.texi:679
msgid "To accumulate text into a buffer, use @kbd{M-x append-to-buffer}.  This reads a buffer name, then inserts a copy of the region into the buffer specified.  If you specify a nonexistent buffer, @code{append-to-buffer} creates the buffer.  The text is inserted wherever point is in that buffer.  If you have been using the buffer for editing, the copied text goes into the middle of the text of the buffer, starting from wherever point happens to be at that moment."
msgstr ""

#. type: Plain text
#: src/killing.texi:687
msgid "Point in that buffer is left at the end of the copied text, so successive uses of @code{append-to-buffer} accumulate the text in the specified buffer in the same order as they were copied.  Strictly speaking, @code{append-to-buffer} does not always append to the text already in the buffer---it appends only if point in that buffer is at the end.  However, if @code{append-to-buffer} is the only command you use to alter a buffer, then point is always at the end."
msgstr ""

#. type: Plain text
#: src/killing.texi:694
msgid "@kbd{M-x prepend-to-buffer} is just like @code{append-to-buffer} except that point in the other buffer is left before the copied text, so successive uses of this command add text in reverse order.  @kbd{M-x copy-to-buffer} is similar, except that any existing text in the other buffer is deleted, so the buffer is left containing just the text newly copied into it."
msgstr ""

#. type: Plain text
#: src/killing.texi:702
msgid "The command @kbd{M-x insert-buffer} can be used to retrieve the accumulated text from another buffer.  This prompts for the name of a buffer, and inserts a copy of all the text in that buffer into the current buffer at point, leaving point at the beginning of the inserted text.  It also adds the position of the end of the inserted text to the mark ring, without activating the mark.  @xref{Buffers}, for background information on buffers."
msgstr ""

#. type: Plain text
#: src/killing.texi:707
msgid "Instead of accumulating text in a buffer, you can append text directly into a file with @kbd{M-x append-to-file}.  This prompts for a filename, and adds the text of the region to the end of the specified file.  The file is changed immediately on disk."
msgstr ""

#. type: Plain text
#: src/killing.texi:712
msgid "You should use @code{append-to-file} only with files that are @emph{not} being visited in Emacs.  Using it on a file that you are editing in Emacs would change the file behind Emacs's back, which can lead to losing some of your editing."
msgstr ""

#. type: Plain text
#: src/killing.texi:715
msgid "Another way to move text around is to store it in a register.  @xref{Registers}."
msgstr ""

#. type: findex
#: src/killing.texi:718 src/killing.texi:843
#, no-wrap
msgid "rectangle"
msgstr ""

#. type: cindex
#: src/killing.texi:719
#, no-wrap
msgid "columns (and rectangles)"
msgstr ""

#. type: cindex
#: src/killing.texi:720
#, no-wrap
msgid "killing rectangular areas of text"
msgstr ""

#. type: Plain text
#: src/killing.texi:728
msgid "@dfn{Rectangle} commands operate on rectangular areas of the text: all the characters between a certain pair of columns, in a certain range of lines.  Emacs has commands to kill rectangles, yank killed rectangles, clear them out, fill them with blanks or text, or delete them.  Rectangle commands are useful with text in multicolumn formats, and for changing text into or out of such formats."
msgstr ""

#. type: cindex
#: src/killing.texi:729
#, no-wrap
msgid "mark rectangle"
msgstr ""

#. type: cindex
#: src/killing.texi:730
#, no-wrap
msgid "region-rectangle"
msgstr ""

#. type: cindex
#: src/killing.texi:731
#, no-wrap
msgid "rectangular region"
msgstr ""

#. type: Plain text
#: src/killing.texi:737
msgid "To specify a rectangle for a command to work on, set the mark at one corner and point at the opposite corner.  The rectangle thus specified is called the @dfn{region-rectangle}.  If point and the mark are in the same column, the region-rectangle is empty.  If they are in the same line, the region-rectangle is one line high."
msgstr ""

#. type: Plain text
#: src/killing.texi:742
msgid "The region-rectangle is controlled in much the same way as the region is controlled.  But remember that a given combination of point and mark values can be interpreted either as a region or as a rectangle, depending on the command that uses them."
msgstr ""

#. type: Plain text
#: src/killing.texi:745
msgid "A rectangular region can also be marked using the mouse: click and drag @kbd{C-M-mouse-1} from one corner of the rectangle to the opposite."
msgstr ""

#. type: kindex
#: src/killing.texi:747 src/killing.texi:786
#, no-wrap
msgid "C-x r k"
msgstr ""

#. type: table
#: src/killing.texi:750
msgid "Kill the text of the region-rectangle, saving its contents as the last killed rectangle (@code{kill-rectangle})."
msgstr ""

#. type: kindex
#: src/killing.texi:750 src/killing.texi:805
#, no-wrap
msgid "C-x r M-w"
msgstr ""

#. type: table
#: src/killing.texi:753
msgid "Save the text of the region-rectangle as the last killed rectangle (@code{copy-rectangle-as-kill})."
msgstr ""

#. type: kindex
#: src/killing.texi:753 src/killing.texi:787
#, no-wrap
msgid "C-x r d"
msgstr ""

#. type: table
#: src/killing.texi:755
msgid "Delete the text of the region-rectangle (@code{delete-rectangle})."
msgstr ""

#. type: kindex
#: src/killing.texi:755 src/killing.texi:811
#, no-wrap
msgid "C-x r y"
msgstr ""

#. type: table
#: src/killing.texi:758
msgid "Yank the last killed rectangle with its upper left corner at point (@code{yank-rectangle})."
msgstr ""

#. type: kindex
#: src/killing.texi:758 src/killing.texi:826
#, no-wrap
msgid "C-x r o"
msgstr ""

#. type: table
#: src/killing.texi:762
msgid "Insert blank space to fill the space of the region-rectangle (@code{open-rectangle}).  This pushes the previous contents of the region-rectangle to the right."
msgstr ""

#. type: kindex
#: src/killing.texi:762 src/killing.texi:842
#, no-wrap
msgid "C-x r N"
msgstr ""

#. type: table
#: src/killing.texi:766
msgid "Insert line numbers along the left edge of the region-rectangle (@code{rectangle-number-lines}).  This pushes the previous contents of the region-rectangle to the right."
msgstr ""

#. type: kindex
#: src/killing.texi:766 src/killing.texi:828
#, no-wrap
msgid "C-x r c"
msgstr ""

#. type: table
#: src/killing.texi:769
msgid "Clear the region-rectangle by replacing all of its contents with spaces (@code{clear-rectangle})."
msgstr ""

#. type: item
#: src/killing.texi:769
#, no-wrap
msgid "M-x delete-whitespace-rectangle"
msgstr ""

#. type: table
#: src/killing.texi:772
msgid "Delete whitespace in each of the lines on the specified rectangle, starting from the left edge column of the rectangle."
msgstr ""

#. type: item
#: src/killing.texi:772
#, no-wrap
msgid "C-x r t @var{string} @key{RET}"
msgstr ""

#. type: table
#: src/killing.texi:775
msgid "Replace rectangle contents with @var{string} on each line (@code{string-rectangle})."
msgstr ""

#. type: item
#: src/killing.texi:775
#, no-wrap
msgid "M-x string-insert-rectangle @key{RET} @var{string} @key{RET}"
msgstr ""

#. type: table
#: src/killing.texi:777
msgid "Insert @var{string} on each line of the rectangle."
msgstr ""

#. type: item
#: src/killing.texi:777
#, no-wrap
msgid "C-x @key{SPC}"
msgstr ""

#. type: table
#: src/killing.texi:781
msgid "Toggle Rectangle Mark mode (@code{rectangle-mark-mode}).  When this mode is active, the region-rectangle is highlighted and can be shrunk/grown, and the standard kill and yank commands operate on it."
msgstr ""

#. type: Plain text
#: src/killing.texi:785
msgid "The rectangle operations fall into two classes: commands to erase or insert rectangles, and commands to make blank rectangles."
msgstr ""

#. type: findex
#: src/killing.texi:788
#, no-wrap
msgid "kill-rectangle"
msgstr ""

#. type: findex
#: src/killing.texi:789
#, no-wrap
msgid "delete-rectangle"
msgstr ""

#. type: Plain text
#: src/killing.texi:797
msgid "There are two ways to erase the text in a rectangle: @kbd{C-x r d} (@code{delete-rectangle}) to delete the text outright, or @kbd{C-x r k} (@code{kill-rectangle}) to remove the text and save it as the @dfn{last killed rectangle}.  In both cases, erasing the region-rectangle is like erasing the specified text on each line of the rectangle; if there is any following text on the line, it moves backwards to fill the gap."
msgstr ""

#. type: Plain text
#: src/killing.texi:804
msgid "Killing a rectangle is not killing in the usual sense; the rectangle is not stored in the kill ring, but in a special place that only records the most recent rectangle killed.  This is because yanking a rectangle is so different from yanking linear text that different yank commands have to be used.  Yank-popping is not defined for rectangles."
msgstr ""

#. type: findex
#: src/killing.texi:806
#, no-wrap
msgid "copy-rectangle-as-kill"
msgstr ""

#. type: Plain text
#: src/killing.texi:810
msgid "@kbd{C-x r M-w} (@code{copy-rectangle-as-kill}) is the equivalent of @kbd{M-w} for rectangles: it records the rectangle as the last killed rectangle, without deleting the text from the buffer."
msgstr ""

#. type: findex
#: src/killing.texi:812
#, no-wrap
msgid "yank-rectangle"
msgstr ""

#. type: Plain text
#: src/killing.texi:818
msgid "To yank the last killed rectangle, type @kbd{C-x r y} (@code{yank-rectangle}).  The rectangle's first line is inserted at point, the rectangle's second line is inserted at the same horizontal position one line vertically below, and so on.  The number of lines affected is determined by the height of the saved rectangle."
msgstr ""

#. type: Plain text
#: src/killing.texi:822
msgid "For example, you can convert two single-column lists into a double-column list by killing one of the single-column lists as a rectangle, and then yanking it beside the other list."
msgstr ""

#. type: Plain text
#: src/killing.texi:825
msgid "You can also copy rectangles into and out of registers with @kbd{C-x r r @var{r}} and @kbd{C-x r i @var{r}}.  @xref{Rectangle Registers}."
msgstr ""

#. type: findex
#: src/killing.texi:827
#, no-wrap
msgid "open-rectangle"
msgstr ""

#. type: findex
#: src/killing.texi:829
#, no-wrap
msgid "clear-rectangle"
msgstr ""

#. type: Plain text
#: src/killing.texi:834
msgid "There are two commands you can use for making blank rectangles: @kbd{C-x r c} (@code{clear-rectangle}) blanks out existing text in the region-rectangle, and @kbd{C-x r o} (@code{open-rectangle}) inserts a blank rectangle."
msgstr ""

#. type: findex
#: src/killing.texi:835
#, no-wrap
msgid "delete-whitespace-rectangle"
msgstr ""

#. type: Plain text
#: src/killing.texi:841
msgid "@kbd{M-x delete-whitespace-rectangle} deletes horizontal whitespace starting from a particular column.  This applies to each of the lines in the rectangle, and the column is specified by the left edge of the rectangle.  The right edge of the rectangle does not make any difference to this command."
msgstr ""

#. type: Plain text
#: src/killing.texi:851
msgid "The command @kbd{C-x r N} (@code{rectangle-number-lines}) inserts line numbers along the left edge of the region-rectangle.  Normally, the numbering begins from 1 (for the first line of the rectangle).  With a prefix argument, the command prompts for a number to begin from, and for a format string with which to print the numbers (@pxref{Formatting Strings,,, elisp, The Emacs Lisp Reference Manual})."
msgstr ""

#. type: kindex
#: src/killing.texi:852
#, no-wrap
msgid "C-x r t"
msgstr ""

#. type: findex
#: src/killing.texi:853
#, no-wrap
msgid "string-rectangle"
msgstr ""

#. type: Plain text
#: src/killing.texi:860
msgid "The command @kbd{C-x r t} (@code{string-rectangle}) replaces the contents of a region-rectangle with a string on each line.  The string's width need not be the same as the width of the rectangle.  If the string's width is less, the text after the rectangle shifts left; if the string is wider than the rectangle, the text after the rectangle shifts right."
msgstr ""

#. type: findex
#: src/killing.texi:861
#, no-wrap
msgid "string-insert-rectangle"
msgstr ""

#. type: Plain text
#: src/killing.texi:865
msgid "The command @kbd{M-x string-insert-rectangle} is similar to @code{string-rectangle}, but inserts the string on each line, shifting the original text to the right."
msgstr ""

#. type: findex
#: src/killing.texi:866
#, no-wrap
msgid "rectangle-mark-mode"
msgstr ""

#. type: Plain text
#: src/killing.texi:874
msgid "The command @kbd{C-x @key{SPC}} (@code{rectangle-mark-mode}) toggles whether the region-rectangle or the standard region is highlighted (first activating the region if necessary).  When this mode is enabled, commands that resize the region (@kbd{C-f}, @kbd{C-n} etc.)@: do so in a rectangular fashion, and killing and yanking operate on the rectangle.  @xref{Killing}.  The mode persists only as long as the region is active."
msgstr ""

#. type: Plain text
#: src/killing.texi:879
msgid "Unlike the standard region, the region-rectangle can have its corners extended past the end of buffer, or inside stretches of white space that point normally cannot enter, like in the middle of a TAB character."
msgstr ""

#. type: findex
#: src/killing.texi:880
#, no-wrap
msgid "rectangle-exchange-point-and-mark"
msgstr ""

#. type: findex
#: src/killing.texi:881
#, no-wrap
msgid "exchange-point-and-mark@r{, in rectangle-mark-mode}"
msgstr ""

#. type: kindex
#: src/killing.texi:882
#, no-wrap
msgid "C-x C-x@r{, in rectangle-mark-mode}"
msgstr ""

#. type: Plain text
#: src/killing.texi:888
msgid "When the region is in rectangle-mark-mode, @kbd{C-x C-x} runs the command @code{rectangle-exchange-point-and-mark}, which cycles between the four corners of the region-rectangle.  This comes in handy if you want to modify the dimensions of the region-rectangle before invoking an operation on the marked text."
msgstr ""

#. type: vindex
#: src/killing.texi:891 src/killing.texi:892
#, no-wrap
msgid "cua-mode"
msgstr ""

#. type: cindex
#: src/killing.texi:893
#, no-wrap
msgid "CUA key bindings"
msgstr ""

#. type: vindex
#: src/killing.texi:894
#, no-wrap
msgid "cua-enable-cua-keys"
msgstr ""

#. type: Plain text
#: src/killing.texi:898
msgid "The command @kbd{M-x cua-mode} sets up key bindings that are compatible with the Common User Access (CUA) system used in many other applications."
msgstr ""

#. type: Plain text
#: src/killing.texi:906
msgid "When CUA mode is enabled, the keys @kbd{C-x}, @kbd{C-c}, @kbd{C-v}, and @kbd{C-z} invoke commands that cut (kill), copy, paste (yank), and undo respectively.  The @kbd{C-x} and @kbd{C-c} keys perform cut and copy only if the region is active.  Otherwise, they still act as prefix keys, so that standard Emacs commands like @kbd{C-x C-c} still work.  Note that this means the variable @code{mark-even-if-inactive} has no effect for @kbd{C-x} and @kbd{C-c} (@pxref{Using Region})."
msgstr ""

#. type: Plain text
#: src/killing.texi:911
msgid "To enter an Emacs command like @kbd{C-x C-f} while the mark is active, use one of the following methods: either hold @kbd{Shift} together with the prefix key, e.g., @kbd{S-C-x C-f}, or quickly type the prefix key twice, e.g., @kbd{C-x C-x C-f}."
msgstr ""

#. type: Plain text
#: src/killing.texi:915
msgid "To disable the overriding of standard Emacs binding by CUA mode, while retaining the other features of CUA mode described below, set the variable @code{cua-enable-cua-keys} to @code{nil}."
msgstr ""

#. type: Plain text
#: src/killing.texi:919
msgid "CUA mode by default activates Delete-Selection mode (@pxref{Mouse Commands})  so that typed text replaces the active region.  To use CUA without this behavior, set the variable @code{cua-delete-selection} to @code{nil}."
msgstr ""

#. type: cindex
#: src/killing.texi:920
#, no-wrap
msgid "rectangle highlighting"
msgstr ""

#. type: Plain text
#: src/killing.texi:928
msgid "CUA mode provides enhanced rectangle support with visible rectangle highlighting.  Use @kbd{C-@key{RET}} to start a rectangle, extend it using the movement commands, and cut or copy it using @kbd{C-x} or @kbd{C-c}.  @key{RET} moves the cursor to the next (clockwise) corner of the rectangle, so you can easily expand it in any direction.  Normal text you type is inserted to the left or right of each line in the rectangle (on the same side as the cursor)."
msgstr ""

#. type: Plain text
#: src/killing.texi:932
msgid "You can use this rectangle support without activating CUA by calling the @code{cua-rectangle-mark-mode} command.  There's also the standard command @code{rectangle-mark-mode}, see @ref{Rectangles}."
msgstr ""

#. type: Plain text
#: src/killing.texi:937
msgid "With CUA you can easily copy text and rectangles into and out of registers by providing a one-digit numeric prefix to the kill, copy, and yank commands, e.g., @kbd{C-1 C-c} copies the region into register @code{1}, and @kbd{C-2 C-v} yanks the contents of register @code{2}."
msgstr ""

#. type: cindex
#: src/killing.texi:938
#, no-wrap
msgid "global mark"
msgstr ""

#. type: Plain text
#: src/killing.texi:945
msgid "CUA mode also has a global mark feature which allows easy moving and copying of text between buffers.  Use @kbd{C-S-@key{SPC}} to toggle the global mark on and off.  When the global mark is on, all text that you kill or copy is automatically inserted at the global mark, and text you type is inserted at the global mark rather than at the current position."
msgstr ""

#. type: Plain text
#: src/killing.texi:951
msgid "For example, to copy words from various buffers into a word list in a given buffer, set the global mark in the target buffer, then navigate to each of the words you want in the list, mark it (e.g., with @kbd{S-M-f}), copy it to the list with @kbd{C-c} or @kbd{M-w}, and insert a newline after the word in the target list by pressing @key{RET}."
msgstr ""

